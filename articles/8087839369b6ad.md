---
title: "時刻差分のアルゴリズム：日をまたぐ時間差も考慮した正確な計算方法"
emoji: "🕑️"
type: "tech"          # or "idea"
topics: ["Python", "アルゴリズム", "初心者向け", "time", "log"]
published: true
---

# ざっくり先に確認しておきたいこと
- [**アルゴリズムって何？**](https://zenn.dev/zoldof/articles/7c9a208402e9ae)（※別の記事にとびます）
「アルゴリズムって聞いたことあるけど、なんだっけ…？」という人向けに、やさしくまとめてます。
- [**この記事の進め方について**](https://zenn.dev/zoldof/scraps/ea70ec179f567c#各アルゴリズムを説明するにあたって用いる文章構成)（※別の記事にとびます）
どういう流れで説明してるか、ざっくり紹介してます。
読む順番が気になる人はちらっとどうぞ。

# はじめに
「ログ見ると、開始と終了の時刻はあるけど、差分は自分で計算しないと…」
「23:55から00:10って、15分だよな…？ うっかり間違えそう」

こんなふうに、時刻の差を計算する処理って、地味だけどあちこちで出てきます。
今回は、時刻差分のアルゴリズムをコードと一緒に紹介していきます。

# このアルゴリズムで出来ること
$hh$:$mm$:$ss$（時:分:秒）形式で指定された2つの時刻の差分を求める

# 動作順序
①2つの指定時刻をそれぞれ［時間，分，秒］に分ける
②2つの時刻の［時間の差，分の差，秒の差］を求める
③時間差を3600倍，分差を60倍する
④すべての差を合計すると［秒］の時刻差分が求まる
⑤時刻表示とするため、まずは差分を3600で割り、その商が［時間］部分になる
⑥⑤の余りをあらたに時刻差分とする
⑦この時刻差分を60で割った商が［分］になり、余りが［秒］部分になる

![時刻差分の動作概要](https://storage.googleapis.com/zenn-user-upload/c196e8deae27-20240905.jpg)
::: details 計算対象選別
|判定|計算対象|関係|数値|
|:--:|--|:--:|:--:|
||データの比較回数|=|0|
||データの交換回数|=|0|
|○|関数の呼び出し回数|=|1|
:::
::: details 変数定義
|変数にする対象|変数|時間|分|秒|
|--|:--:|--:|--:|--:|
|１時間|$h$|$1×h$|$60×h$|$60×60×h$|
|１分間|$m$||$1×m$|$60×m$|
|１秒間|$s$|||$1×s$|
|１つ目の時刻|$a_1$|
|２つ目の時刻|$a_2$|
|秒の時刻差分|$S_t$|
:::

# 一般化
1つ目の時刻の秒部分は $s(a_1)$ は $hh$:$mm$:$ss$ 形式で下2桁にあたる部分であり
それをふまえて1つ目の時刻全体を秒であらわすと
$$a_1=[60×60×h(a_1)]+[60×m(a_1)]+[1×s(a_1)]$$共通因数でくくると
$$a_1=60\{[60×h(a_1)]+m(a_1)\}+s(a_1)$$同様に2つ目の時刻を秒であらわすと
$$a_2=60\{[60×h(a_2)]+m(a_2)\}+s(a_2)$$$a_2>a_1$ のとき $S_t=a_2-a_1$ なので
$$S_t=60\{⟮60×[h(a_2)-h(a_1)]⟯+[m(a_2)-m(a_1)]\}+[s(a_2)-s(a_1)]$$ここまでで秒の時刻差分が求まり
これは $hh$:$mm$:$ss$ 形式で言うと以下のようになる
$${\frac {S_t} {3600}\ 時間\ \frac {S_t\%3600} {60}\ 分\ (S_t\%3600)\%60\ 秒}$$この式は計算量を指し示しておらず時刻差分を求めるための文字式でしかない

別途で計算量を表現するならば上記のように
- 秒の時刻差分 $S_t$ を求める
- 求めた時刻差分を時刻表示にして出力する

この２つの処理が可能な関数を呼び出すことになる
※ここで関数の引数は2つの時刻 $a_1$ と $a_2$ である

よって計算量としては関数を1回呼び出すことに等しいので
$T(n)=1$
漸近計算量は $O(1)$ である

# 実装
## Python
```python
def parse_time(time_str):
    h, m, s = map(int, time_str.split(":"))
    return h, m, s

def to_seconds(h, m, s):
    return h * 3600 + m * 60 + s

def from_seconds(total_seconds):
    if total_seconds < 0:
        total_seconds += 24 * 3600
    h = total_seconds // 3600
    total_seconds %= 3600
    m = total_seconds // 60
    s = total_seconds % 60
    return f"{h:02}:{m:02}:{s:02}"

def main(start, end):
    h1, m1, s1 = parse_time(start)
    h2, m2, s2 = parse_time(end)
    sec1 = to_seconds(h1, m1, s1)
    sec2 = to_seconds(h2, m2, s2)
    diff = sec2 - sec1
    return from_seconds(diff)
```

いろんなライブラリで時刻差分をとったときの実測値がこちら。

| ライブラリ | 実行時間 | メモリ（現時点） | メモリ（ピーク） | 
|------------|----------|-------------------|-------------------|
| 自作        | 0.0001秒 | 49B               | 339B              | 
| datetime   | 0.0038秒 | 615,243B          | 617,794B          | 
| dateutil   | 0.0155秒 | 1,395,562B        | 1,395,962B        | 
| pandas     | 0.6152秒 | 30,851,005B       | 30,885,673B       | 

- 詳しい検証はこちらのページで行いました
  - [標準ライブラリを使うか、自作するか？ ― 時刻差分で考える判断基準 ―](https://zenn.dev/zoldof/articles/tech-algo-library)

# 動作検証
- [コードを見ながら時刻差分のアルゴリズムを試せるページ](https://zoldof.github.io/pyodide/pyodide-runner.html?ui=time-calc_01)

# 参考サイト
- 一週間で身につくアルゴリズムとデータ構造
  - [入門編4日目：アルゴリズムの例①](https://sevendays-study.com/algorithm/pr-day4.html)
